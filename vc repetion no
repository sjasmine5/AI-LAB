from termcolor import colored
import random

# Function to initialize the board with user-defined dirt cells
def initialize_board(n, dirt_positions):
    board = [[' ' for _ in range(n)] for _ in range(n)]
    for x, y in dirt_positions:
        if 0 <= x < n and 0 <= y < n:
            board[x][y] = 'D'
    return board

# Function to print the board with row and column numbers
def print_board(board, vacuum_position):
    n = len(board)
    print("    " + "   ".join([str(i + 1) for i in range(n)]))
    print("   +" + "---+" * n)
    for i, row in enumerate(board):
        row_display = []
        for j, cell in enumerate(row):
            if [i, j] == vacuum_position:
                row_display.append(colored('V', 'blue'))
            elif cell == 'D':
                row_display.append(colored(cell, 'red'))
            else:
                row_display.append(cell)
        print(f" {i + 1} | " + " | ".join(row_display) + " |")
        print("   +" + "---+" * n)

# Function to find the nearest dirty cell
def find_nearest_dirty_cell(board, vacuum_position):
    n = len(board)
    queue = [(vacuum_position, 0)]  # (position, distance)
    visited = set()
    visited.add(tuple(vacuum_position))
    
    while queue:
        (x, y), dist = queue.pop(0)
        if board[x][y] == 'D':
            return (x, y)  # Return the coordinates of the nearest dirty cell
        
        # Add neighbors to the queue
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:
                visited.add((nx, ny))
                queue.append(((nx, ny), dist + 1))
    
    return None  # No dirty cell found

# Function to simulate the vacuum cleaner's movement
def vacuum_cleaner_simulation(n):
    # Get the dirt positions from the user
    dirt_positions = []
    print(f"Enter the coordinates for the dirt positions (1-{n} for both row and column).")
    while True:
        try:
            dirt_input = input("Enter dirt position as 'row col' or type 'done' to finish: ")
            if dirt_input.lower() == 'done':
                break
            row, col = map(int, dirt_input.split())
            if 1 <= row <= n and 1 <= col <= n:
                dirt_positions.append((row - 1, col - 1))
            else:
                print(f"Invalid input. Please enter values between 1 and {n}.")
        except ValueError:
            print("Invalid input. Please enter the dirt position as 'row col'.")
    
    # Initialize the board
    board = initialize_board(n, dirt_positions)
    
    # Set the initial vacuum position
    vacuum_position = [random.randint(0, n - 1), random.randint(0, n - 1)]
    print(f"Vacuum cleaner starts at position {vacuum_position[0] + 1}-{vacuum_position[1] + 1}")
    print("Initial Board:")
    print_board(board, vacuum_position)

    steps = 0
    while True:
        # Find the nearest dirty cell
        target = find_nearest_dirty_cell(board, vacuum_position)
        if not target:
            print("All dirty cells are clean!")
            break
        
        # Move the vacuum cleaner to the target
        tx, ty = target
        if tx > vacuum_position[0]:  # Move down
            vacuum_position[0] += 1
        elif tx < vacuum_position[0]:  # Move up
            vacuum_position[0] -= 1
        elif ty > vacuum_position[1]:  # Move right
            vacuum_position[1] += 1
        elif ty < vacuum_position[1]:  # Move left
            vacuum_position[1] -= 1
        
        # Clean the dirt if reached the target
        if vacuum_position == [tx, ty] and board[tx][ty] == 'D':
            board[tx][ty] = ' '
            print(f"Cleaned dirt at position {tx + 1}-{ty + 1}.")
        
        steps += 1
        print(f"\nStep {steps}:")
        print_board(board, vacuum_position)

# Start the simulation
if __name__ == "__main__":
    n = int(input("Enter the size of the board (n x n): "))
    vacuum_cleaner_simulation(n)
